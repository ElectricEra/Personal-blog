---
url: event-driven-architecture
title: Event-driven architecture
date: 2023-03-01
spoiler: Розкажу що це таке, в яких випадках доречно використовувати, як з цим працювати та про що слід пам'ятати при проектуванні event-driven бекенд архітектури.
---

# Event-driven architecture

## Огляд
Event-driven architecture складається з трьох основних компонент:
- event producers
- event routers
- event consumers

Як ви помітили, у кожному компоненті є слово івент.

Івент - це певна структурна одиниця, доволі часто, це просто об’єкт, який містить у собі якусь інформацію. Інформацією може бути будь-яка подія у нашій системі - дані, виміри чи будь-що інше, що несе змістову нагрузку у нашій системі.

---

## Event-producer
Івент продюсери - це частини системи, які можуть породити івент, джерела інформації у системі.

- Приклад зі сторони фронтенду - звичайний клік по кнопці. Для прикладу, кнопка “Оплатити”. Івент продюсер - клік по кнопці. Івент - інформація про банківські деталі, яка були заповнені користувачем, його дані, як користувача та будь-які інші, які потрібні нашій системі.
- Приклад зі сторони бекенду - запис у базу даних. Івент продюсером є база даних, а івентом є об’єкт, який містить інформацію, яка була записана, хто це зробив, час, та будь-яку іншу додаткову, яку ми захочемо.
- Також, прикладом можуть бути якісь фізичні дії чи прилади. Наприклад, дзвінок в підтримку. Перед тим, як з’єднати користувача з оператором, ми можемо створити івент, який буде містити якусь інформацію про того, хто дзвонить.

---

## Event router
Тепер в нас в системі є івенти, які ми створили. У нас є інформація, з якою ми готові працювати. Цю інформацію потрібно кудись передати.

За цю логіку відповідає event router. Ця компонента event-driven системи відповідає за правильний розподіл івентів, які надходять у систему. Вона містить певну бізнес логіку, яка визначає куди даний меседж повинен бути направленим.

Для прикладу, маючи івент customerSupportCallStarted, у якому інформація про дзвінок у тех підтримку, event-router направить дане повідомлення event-consumer-у, який знає як його опрацювати.

---

## Event consumer
Отримавши повідомлення, у дію вступають event-consumer-и. Їх основною метою є отримання івенту та його обробка. Саме на цьому етапі відбувається “взаємодія” event-driven системи з іншими частинами додатку - запити до баз даних чи до інших сервісів.

Отримавши івент, що хтось зателефонував у тех-підтримку, ми можемо запустити функцію, яка призначить відповідного оператора на дзвінок.

---

## Event flow
Ці 3 компоненти системи завжди взаємодіють одна з одною.
Створивши івент, він перенаправляється до системи, яка здатна його обробити. Після його обробки, виникає необхідність у створенні наступного івента. Який у свою чергу, знову буде направленим до наступного його обробника.

Таким чином, у нас створюється “коло” - створити - направити - обробити

Даний потік є основою івент-дрівен архітектури.

Тримаючи це в голові, трішки змінюється підхід до написання коду і розуміння роботи системи. У event-driven системі створюються “ланцюжки”, де ми поступово обробляємо івенти і створюємо нові, поки не дійдемо до певного кінцевого стану.

---

## Приклад
Розглянемо на прикладі як за допомогою цих принципів ми можемо реалізувати роботу системи.
Завданням буде написання логіки щодо підтвердження замовлення, реалізоване за допомогою двох архітектурних підходів: “Монолітної” та “Івент-дрівен” (із використанням “Клієнт-Серверної” моделі у обох випадках).

Після натискання кнопки “Оплатити”

---

### Монолітна система
- Фронтенд
  1. Натискаємо кнопку “Оплатити”
  2. Надсилаємо запит на бекенд

- Бекенд
  1. Перевіряє, чи пройшла оплата.
  2. Перевіряє, чи наявні всі товари в корзині.
  3. Перевіряє, чи ціна товару правильна.
  4. Створює замовлення у системі.
  5. Створює ідентифікатор у системі.
  6. Повертає відповідь користувачу.

---

### Івент-дрівен архітектура
- Фронтенд
  1. Натискаємо кнопку “Оплатити”
  2. Надсилаємо запит на бекенд

- Бекенд
  1. Створює ідентифікатор у системі.
  2. Створює івент “замовлення отримано”.
  3. Повертає відповідь користувачу.

- Сервер, який опрацьовує замовлення:
  - (очікує команду “замовлення отримано”)
    1. Перевіряє чи пройшла оплата
    2. Створює івент “оплата успішна”
  - (очікує команду “оплата успішна”)
    1. Перевіряє, чи наявні всі товари в корзині
    2. Перевіряє, чи ціна товару правильна
    3. Створює івент “корзина актуальна”
  - ...

---

## Івенти - одна логічна одиниця
Коли ми думаємо про івенти, ми повинні розуміти, що кожен івент у системі є самостійною логічною одиницею. Він виконує певну конкретну функцію.

Завдяки цьому, ми можемо розбивати складніші і більші завдання на менші та простіші.

Такі одиниці:
- Простіше зрозуміти. Бо відповідає за конкретну функцію
- Простіше покривати юніт тестами. В нас є відносно маленька функція

---

## Івентами можна створювати “логічні ланцюжки”
З таких дрібних елементів ми можемо створювати більші сутності. Кожен наш івент можна назвати “ланкою” і з’єднати з будь-якою іншою, щоб створити “ланцюжок”.

Ланцюжки, у свою чергу, вже виконують поставлене завдання.
- Отримуємо можливіть перевикористовувати івенти.
- Отримуємо можливість слідкувати за “процесом виконання”, бо завжди відомо на якому етапі система перебуває у конкретний момент часу

---

## Івенти - додатковий рівень абстракції
В івент-дрівен архітектурі у нас створюється система, у якій для опрацювання завдання, ми змушені передавати інформацію між її різними компонентами.

Це створює додаткову нагрузку на нашу систему, оскільки:
- На кожен івент у нас виникає необхідність передачі даних між сервісами, які опрацьовують її.
- Виникає необхідність передавати усю інформацію між event-consumer-ами за допомогою івентів

---

## Як ефективно використовувати event-driven architecture?
В загальному, event-driven architecture є незалежною від технології. Її можна використовувати разом з іншими паттернами розробки бекенд систем. На прикладі, який був розглянутий раніше, була комбінація Event-driven architecture та “Клієнт-Серверної” моделі.

Сам по собі цей паттерн формує підхід до роботи з інформацією, не вимагає від системи те, яким чином може бути реалізована будь-яка з її трьох компонент - event producers, event routers, event consumers.

Її можна сумістити з будь-якими іншими паттернами, які вирішують проблему побудови серверів. Але існують певні рішення, які доповнюють основні компоненти event-driven архітектури найефективніше і використовуються в парі практично завжди.
- event-router - система, яка транспортує івенти до черг (Queue)
- event-consumer - системи, які побудовані навколо певної сутності (microservice або serverless чи інші реалізації).

---

## Використання черг
Маючи змогу будувати ланцюжки з івентів, ми можемо працювати з івентами поступово, один за одним. Event-router передає івент для event-consumer-а, який, у свою чергу опрацьовує повідомлення.

Основною ідеєю Event-driven архитектури є реакція на івенти, які виникають, тому ми повинні налаштувати цей процес в такому вигляді, щоб ми могли максимально ефективно рухати івенти у системі.

Якщо між цими двома компонентами системи є queue:
- Зʼявляється можливість розпаралелити в часі цей процес. Івенти збираються в чергах. Кожен меседж обробляється саме тоді, коли сервер готовий обробити запит.
- Якщо меседж не виконується успішно - кожна ланка ланцюжка подій може мати ретрай
- Є можливість зберегти івенти, які не змогли бути опрацьованими системою.

---

## Дебаг та аналітика
Маючи queue, ми маємо можливість користуватись і іншими перевагами, які надає цей підхід:
- З такими малими структурними одиницями легко робити аналітику
- Завжди відомо де сталась проблема, оскільки відомо де саме у системі знаходяться неопрацьовані івенти.

---

## Нюанси, до яких потрібно бути готовим:
- Робити івенти потрібно ідемпотентні
  - Якщо у системі є можливість опрацьовувати один івент декілька разів, важливо зробити так, що у разі успішного виконання івенту, наступні його виконання не повпливають на систему. (П.С. Успішне виконання - це як генерація наступного івенту, так і генерація системою помилки. Неуспішне виконання - коли стався такий збій, при якому можна спробувати опрацювати івент ще раз)
- Варто використовувати FIFO queue
  - Оскільки система опрацьовує меседжі один за одним та може накопичувати їх у разі перегрузу системи, є сенс опрацьовувати спочатку старіші повідомлення, а потім новіші, щоб event-consumer-и не повертали неуспішні меседжі назад у систему
